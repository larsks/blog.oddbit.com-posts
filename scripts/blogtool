#!/usr/bin/python

import click
import contextlib
import datetime
import git
import io
import logging
import tempfile
import yaml

from itertools import zip_longest
from pathlib import Path

LOG = logging.getLogger(__name__)


def stripped(fd):
    for line in fd:
        yield line.rstrip()


def takeuntil(predicate, iterable):
    '''return items from an iterable until predicate is true'''
    for x in iterable:
        yield x
        if predicate(x):
            break


@contextlib.contextmanager
def checkout(repo, branch):
    old_branch = repo.head.ref

    if old_branch != branch:
        if repo.index.diff(None):
            raise click.ClickException(
                f'attempt to switch {old_branch.name} -> {branch.name} with unstaged changes')
        branch.checkout()

    try:
        yield
    finally:
        if old_branch != branch:
            if repo.index.diff(None):
                raise click.ClickException(
                    f'attempt to switch {branch.name} -> {old_branch.name} with unstaged changes')

            old_branch.checkout()


class Context:
    def __init__(self, repo_path, main_branch='master'):
        self.repo = git.Repo(repo_path)
        self.main_branch = self.repo.refs[main_branch]


class Post:
    '''A blog post'''

    def __init__(self, path):
        self.path = Path(path)
        self.filename = self.path.name
        self.date = self.filename[:10]
        self.stub = self.filename[11:-3]

        with self.path.open() as fd:
            self.metadata = self.read_metadata(fd)

    def __repr__(self):
        return f'<Post {self.stub} @ {self.date}>'

    def change_date(self, date):
        date_str = date.strftime('%Y-%m-%d')
        self.filename = f'{date_str}-{self.stub}.md'
        self.metadata['date'] = date_str
        self.metadata['filename'] = self.filename
        self.write_metadata()
        old_path = self.path
        self.path = self.path.rename(self.path.parent / self.filename)

        return (old_path, self.path)

    def read_metadata(self, fd):
        md = io.StringIO()

        for ln, line in enumerate(stripped(fd)):
            if ln == 0:
                if line != '---':
                    LOG.warning('no metadata in %s', self.path)
                    return {}
            else:
                if line == '---':
                    break
                else:
                    md.write(line)
                    md.write('\n')

        return yaml.safe_load(md.getvalue())

    def write_metadata(self):
        with self.path.open() as fd, tempfile.NamedTemporaryFile(
                mode='w', dir=self.path.parent, prefix='post') as tmp:
            self.read_metadata(fd)
            tmp.write('---\n')
            tmp.write(yaml.safe_dump(self.metadata, default_flow_style=False))
            tmp.write('---\n')
            tmp.write(fd.read())

            self.path.unlink()
            Path(tmp.name).link_to(self.path)


@click.group()
@click.option('--repo', '-r', 'repo_path', default='.')
@click.option('--verbose', '-v', count=True)
@click.pass_context
def main(ctx, repo_path, verbose):
    ctx.obj = Context(repo_path)

    try:
        loglevel = ['WARNING', 'INFO', 'DEBUG'][verbose]
    except IndexError:
        loglevel = 'DEBUG'

    logging.basicConfig(level=loglevel)


@main.command()
@click.pass_obj
def lsdraft(ctx):
    drafts = [branch for branch in ctx.repo.branches
              if branch.name.startswith('draft/')]

    print('\n'.join(draft.name for draft in drafts))


def find_posts(ctx, branch, merge_base):
    '''find all post/* files between merge_base and branch'''

    cur = branch.commit
    posts = set()

    # get a list of commits from merge_base to branch.
    commits = list(
        reversed(
            list(
                takeuntil(
                    lambda commit: commit == merge_base,
                    ctx.repo.iter_commits(branch)
                )
            )
        )
    )

    # iterate over (previous, current) commits, looking for
    # added, renamed, or deleted files.
    for prev, cur in zip_longest(commits, commits[1:]):
        if cur is None:
            break

        LOG.debug('examining commit %s', cur)
        diff_index = prev.diff(cur)
        for diff in diff_index:
            if diff.change_type in ['A', 'R']:
                if diff.a_path.startswith('post/'):
                    LOG.info('found post %s', diff.b_path)
                    posts.add(diff.b_path)

            if diff.change_type in ['R', 'D']:
                LOG.debug('discarding %s', diff.a_path)
                posts.discard(diff.a_path)

        cur = cur.parents[0]

    return posts


@main.command()
@click.argument('draft_name')
@click.pass_obj
def fix_date(ctx, draft_name):
    if not draft_name.startswith('draft/'):
        draft_name = f'draft/{draft_name}'

    try:
        branch = ctx.repo.refs[draft_name]
    except IndexError:
        raise click.ClickException(f'no draft named {draft_name}')

    if ctx.repo.index.diff(None):
        raise click.ClickException('cannot operate when there are unstaged changes')

    LOG.info('processing branch %s', branch.name)
    with checkout(ctx.repo, branch):
        try:
            merge_base = ctx.repo.merge_base(ctx.main_branch, branch)[0]
        except IndexError:
            raise click.ClickException(f'failed to find merge base for {draft_name}')

        LOG.info('found merge base %s', merge_base)

        posts = find_posts(ctx, branch, merge_base)

        if len(posts) < 1:
            raise click.ClickException(f'no posts in {draft_name}')

        now = datetime.datetime.now()
        now_str = now.strftime('%Y-%m-%d')

        for post in posts:
            p = Post(post)
            old_path, new_path = p.change_date(now)

            ctx.repo.git.add(old_path)
            ctx.repo.git.add(new_path)

        if ctx.repo.index.diff('HEAD'):
            LOG.info('committing changes')
            ctx.repo.git.commit(message=f'updated to date {now_str}')
        else:
            LOG.info('no changes')


if __name__ == '__main__':
    main()
